\makeatletter
\def\sx@stop{\relax}\def\sx@open{(}\def\sx@close{)}
\def\sx@scan#1{%
  \def\sx@arg{#1}%        save the current token
  \ifx\sx@arg\sx@stop   % is it the end of the list?
    \let\sx@next\relax
  \else
    \ifx\sx@arg\sx@close\else\sx@space\fi % add space unless token is ")"
    {\sx@arg}%                            % write the token
    \ifx\sx@arg\sx@open                   
      \let\sx@space\relax                 % kill next space if token is "("
    \else
      \let\sx@space\;
    \fi
    \let\sx@next\sx@scan                  % scan next token
  \fi\sx@next
}
\newcommand{\sexp}[1]{\let\sx@space\relax\sx@scan#1\relax}
\makeatother

\title{Using genetic programming to evolve algorithms for audio synthesis}
\author{
Chris Donahue \\
Advisors: Peter Stone, Russell Pinkston \\
Department of Computer Science \\
University of Texas at Austin\vspace{-2ex}
}
\date{}

\documentclass[12pt]{article}

\usepackage{natbib}

\begin{document}
\maketitle

\begin{abstract}
This paper presents a system for evolving sound synthesis algorithms using the technique of genetic programming. The investigation of this topic will consist of two parts. The first is to determine if genetic programming can be used to evolve sound synthesis algorithms whose output resembles a target sound. Typically this task involves many hours of human labor to determine an efficient way to mimic a given sound. The second goal is to determine if genetic programming can be used interactively and accessibly by musicians to help them explore the space of novel timbres. This would allow electronic composers access to a wide array of synthesized timbres instead of restricting them to the synthesis algorithms they have available.
\end{abstract}

\section{Introduction}
Timbre is a collection of physical properties of a sound that is frequently explained in terms of its human utility rather than its physical components. The American National Standards Institute defines timbre as ``that attribute of auditory sensation in terms of which a listener can judge that two sounds similarly presented and having the same loudness and pitch are dissimilar'' \citep{american1960american}. The ambiguity lies in determining what exactly ``that attribute'' is and what physical phenomena cause it. This psychoacoustic debate continues to this day after the advent of computer technology introduced both a great road block and a great opportunity in our understand of timbre \citep{erickson1975sound}. Computers have the theoretical ability to render any sound through discrete waveforms and thus the umbrella term timbre can no longer be interpreted as a direct association between certain sounds and the concrete characteristics of the objects that produce them.

Early attempts to characterize the physical components of timbre mostly focused on the relative amplitudes and ratios of partial tones. These assumptions were based perhaps too heavily on Fourier's theorem that any periodic waveform can be decomposed into simple sin wave components \citep{helmholtz1857physiological, helmholtz1954sensations}. Characterizations of timbre that place full emphasis on spectral relationships are antiquated and have been augmented by multidimensional descriptions made up of several components with codependencies \citep{erickson1975sound}. One such description was proposed by J. F. Schouten in 1968 and involves five characteristics \citep{schouten1968perception, erickson1975sound}:
\begin{enumerate}
\item
The range between tonal and noise-like character
\item
The spectral envelope
\item
The time envelope in terms of rise, duration and decay
\item
The changes both of spectral envelope (formant-glide) and fundamental frequency (micro-intonation)
\item
The prefix, an onset of a sound quite dissimilar to the ensuing lasting vibration.
\end{enumerate}

For the purposes of this experiment, these five perceptual characteristics will be used to develop a method for comparing the timbral characteristics of two sounds. A computable metric of timbral comparison that is similar to human judgement is necessary for a genetic algorithm designed to produce sound synthesis algorithms capable of sounding like a target timbre to a human.

\section{Motivations}
Chowning summarized the motivations for this research in his paper detailing the technique of frequency modulation audio synthesis.
\begin{quote}
Of interest in both acoustical re-search and electronic music is the synthesis of natural sound. For the researcher, it is the ultimate test of acoustical theory, while for the composer of electronic music it is an extraordinarily rich point of departure in the domain of timbre, or tone quality. \citep{chowning1973synthesis}
\end{quote}
The concept of timbre is ignored by many if not most musicians today. Acoustic composers typically restrict themselves to given sounds, such as the instruments in a wind ensemble or orchestra. Electronic and electro-acoustic composers have a wider timbral palette to work with but usually restrict themselves to working within the confines of available synthesizers and samples. Wishart said in his book Audible Design \citep{wishart1994audible}:
\begin{quote}
The spectral characteristics of sound have, for so long, been inaccessible to the composer that we have become accustomed to lumping together all aspect of the spectral structure under the catch all term ``timbre''...
\end{quote}	 
These issues suggest the need for alternative and accessible methods of timbre investigation for musicians and researchers. This paper will present a system that allows one to supply a target sound and receive a synthesis algorithm that mimics its timbral characteristics. The system will also allow the user to examine, test and adjust these discovered algorithms to improve their fit. Such capabilities could theoretically allow a musician to utilize an instrument they do not have physical access too from a single recording of its sound. Many electronic musicians utilize synthesis techniques such as additive, subtractive, ring modulation, amplitude modulation, and frequency modulation to create sounds. This paper will also present an interactive genetic algorithm for searching the space of sound synthesis algorithms of which these traditional synthesis techniques are a minuscule subset of the search space.

\section{Sound Synthesis Algorithms}\label{SSA}
Sound synthesis algorithms (SSA's) are typically numerical algorithms for rendering sonically interesting sounds \citep{tolonen1998evaluation}. Perhaps the quintessential SSA is the equation for rendering a sine wave. Mathematically, this equation can be expressed as $sin (2 \times \pi \times f \times t)$ where $f$ is the desired frequency of the sine wave and $t$ is the time since the start of the sine wave in seconds. In the digital domain, time at the $n$th sample would be $n$ divided by $sample rate$.
	
The sine wave rendering equation could be expressed in several different ways. Using prefix notation, it can be expressed equivalently as the S-expression $\sexp{({sin} (\times (\times (\times 2 \pi) f) t))}$. S-expressions are convenient from a computational standpoint as they allow easy evaluation and modification of an equation in a recursive tree structure. The evaluable arrangements of operators and terminals (together referred to as primitives) induce a space of S-expressions. This concept will become more important when this paper details its use of genetic programming.
	
This sine wave rendering equation is so important to the domain of musical sounds that it will be convenient for our purposes to see it as a single, high level unit instead of the combination of eight lower level units as shown in FIGURE. Also included is a depiction of the sine wave rendering equation expressed as a more traditional synthesis topology. TODO: figures
	
\section{Mimicking Acoustic Instruments Using Sound Synthesis Algorithms}
Sound synthesis algorithms are a well studied aspect of computer music, and for as long as they have existed people have been using them to mimic recognizable acoustic timbres.

\subsection{Early Investigations (1950-1970)}
Max Mathews created the first widely used computer program for sound synthesis in 1957 called MUSIC. MUSIC and its descendants in the MUSIC-N family of programs utilize wrapper functions around common synthesis routines called unit generators. This is a similar concept to the wrapping of the sine wave rendering equation into a single S-expression primitive as discussed in \ref{SSA}. Mathews wrote that ``there are no theoretical limitations to the performance of the computer as a source of musical sounds, in contrast to the performance of ordinary instruments.'' \citep{mathews01111963} While this statement can be challenged due to a computer's lack of ability to produce continuous signals, it holds perceptually as any possible discrete wave form can be rendered by a machine. Jean-Claude Risset worked with Mathews in the late 1960's to attempt to produce with a computer sounds that mimicked acoustic instruments. While they were successful in creating brass-like and string-like sounds by analyzing the spectral content of recordings, their conclusion was that ``additional factors must be discovered to yield an impeccable match to a given [instrument]'' \citep{risset1969analysis}.

\subsection{FM Synthesis (1970-1990)}
In 1973 John Chowning introduced a method for utilizing frequency modulation to efficiently synthesize tones with rich harmonic spectra that developed over time. He states in the introduction of the related paper that ``temporal evolution of the spectral components is of critical importance in the determination of timbre'' \citep{chowning1973synthesis}. Frequency modulation was a well-understood concept in broadcasting but had yet to be applied to sound synthesis. The task of efficiently producing spectrally complex tones had presented a major hurdle to mimicking spectrally complex acoustic instruments as computer performance was limited at the time. Chowning himself used FM synthesis to mimic brass, woodwind, percussive sounds, and later a singing voice \citep{chowning1989frequency} with impressive subjective results considering the computational efficiency of the algorithm. Perhaps one of the ``additional factors'' elusive to Mathews and Risset was the temporal development that FM synthesis provides.
Work in the 1980's on mimicking acoustic timbres was largely commercial after Stanford licensed Chowning's work on FM audio synthesis to Yamaha. Audio researchers at Yamaha continued to mimic tones of acoustic instruments by modifying the parameters and carrier/modulation structure of FM synthesis.

\subsection{Genetic Algorithms (1990-present)}
\subsubsection{Traditional Genetic Algorithms}
Genetic algorithms (GA's) were only popularized in the 1980's despite previous decades of theoretical study. TODO: EXPLAIN GENETIC ALGORITHM

In 1993, Horner demonstrated an automation of this task using a genetic algorithm \citep{horner1993machine}. Horner successfully demonstrated a system for optimizing the parameters of a fixed FM synthesis structure with a single modulator and multiple parallel carriers. Johnson used an interactive genetic algorithm to control parameters for a granular synthesis algorithm \citep{johnson1999exploring} and Wehn used ideas from natural selection to explore the parameter space and in a more limited sense the connection space of FM-like synthesizers \citep{wehn1998using}. TODO: expand on this

\subsubsection{Genetic Programming}
John Koza's 1994 book spawned a new class of genetic algorithms altogether \citep{koza1992genetic}. Koza borrowed concepts from traditional genetic algorithms to evolve computer programs and dubbed the technique genetic programming (GP). The programs that GP evolves are S-expressions. An S-expression is a tree representation of a program which can be anything from a simple mathematical expression to infinitely more complicated algorithms involving logic operators and domain-specific operations. TODO: EXPLAIN GENETIC PROGRAMMING)
			
The domain-specific applications of genetic programming are intriguing for sound synthesis as nodes of the S-expression could represent units such as sin wave oscillators and time-varying signal filters as discussed previously. In 2000, Ricardo Garcia successfully demonstrated the technique of GP in the domain of synthesis algorithm generation for target sound matching \citep{garcia2000towards}.

Garcia's approach evolved trees that represented a set of instructions for building sound synthesis topologies such as the topology depicted in figure (TODO: FIGURE ABOVE). This indirect encoding was motivated by the fact that sound synthesis topologies can be cyclical and S-expressions cannot be. However, these non-cyclical ``instruction trees'' could contain instructions to build a cyclical synthesis topology and therefore allow unmodified genetic programming to be utilized to create cyclical synthesis algorithms.

Garcia makes the following statement about his instruction trees "every [instruction] tree maps into a single topology... but a topology can be represented by many different [instruction] trees." \citep{garcia2012automatic}. This leads me to believe that this approach is perhaps not the ideal way to apply GP to sound synthesis as this representation is searching through a larger space of S-expressions that map into a smaller space of synthesis algorithms. The author has also not encountered any examples of SSA's that utilize cyclic topologies to mimic acoustic timbres. Regardless, cyclic behavior could also be represented non-cyclically by the use of a delay buffer primitive if it is found to be necessary. Additionally, Garcia uses sub-optimization of a known number of constants once a topology has been produced. This is an interesting strategy but could theoretically be encoded into GP itself by using ephemeral random constants with numeric mutation \citep{evett1998numeric}. TODO: modify once definitive

\section{Target-Matching GP Search for Sound Synthesis Algorithms}
\subsection{Method}
This experiment will use genetic programming to evolve synthesis algorithms directly, utilizing a set of primitives identified as essential components for mimicking timbres. The inputs to this system are a recorded target sound represented by a WAV file and the fundamental frequency of the target sound. This method differs from Garcia's who treated the system as a black box whose input was a WAV file and whose output was a synthesis topology. I argue that providing the fundamental frequency is a good addition to the inputs of this black box as it prevents the algorithm from having to waste search time to find the fundamental and allows the experimenter to use a MIDI keyboard to test how well the discovered algorithm generalizes to other pitches.
\subsection{Available primitives}
Primitives with arity of $0$ are the terminal nodes of S-expressions. These are the primitives used in all tests unless otherwise noted. TODO: add/remove primatives found to be necessary/not useful
\begin{center}
\begin{tabular}{ | l | l | } \hline
Type & Arity \\ \hline
Addition & 2 \\ \hline
Multiplication & 2 \\ \hline
Frequency and phase modulation oscillator & 2 \\ \hline
Time-varying filters & 3 \\ \hline
ADSR envelope & 1 \\ \hline
Sin wave oscillator & 0 \\ \hline
White noise & 0 \\ \hline
Time-varying numbers & 0 \\ \hline
Ephemeral random constants & 0 \\ \hline
\end{tabular}
\end{center}
\subsection{Loop}
The process of this experiment will involve the following main loop:
\begin{enumerate}
\item
Initial sound synthesis algorithm population
\item
LOOP START:
Run each algorithm to render sound
\item
Evaluate the sound in comparison to the target by means of a fitness function
\item
If $best\ fitness\ found\ <\ threshold\ ||\ number of generations\ >=\ limit$, FINISH and return champion
\item
otherwise render the next generation of individuals using traditional genetic programming operations and return to LOOP START
\end{enumerate}
\subsection{Initial Population}
The random generation of the initial population is a mostly unmodified implementation of Koza's Ramped Half and Half method to generate great diversity from the outset \citep{koza1992genetic}. The only difference is that I do not check for duplicate S-expressions. (TODO: maybe change this). I am using the technique of ephemeral random constants to propagate random constants throughout the population combined with numeric mutation \citep{evett1998numeric}.
\subsection{Fitness Function}
The fitness function I am using is a variation of the fitness function that Garcia used for his system. There are two broad types of fitness functions that could apply in this domain, strictly analytical fitness functions or fitness functions that take human perception into account. Garcia uses the following fitness function: MSEFREQMAG, MSEFREQPHASE, MSEFREQ = MSEFREQMAG + MSEFREQPHASE as an analytical fitness function. In his masters thesis he also presents a perceptual fitness technique called Simultaneous Frequency Masking that is not currently being utilized. Algorithms that produce silence are assigned a penalty fitness. TODO: edit for clarity/to what I'm actually doing once that is finalized
\subsection{Genetic Operations}
The genetic operations I am utilizing are those typically associated with genetic programming. Individuals are selected proportionally to their assigned fitnesses (where lower is better due to the fact that fitness is a calculation of error). During the reproduction stage, part of the next generation is produced by selecting two parents, swapping two randomly selected subtrees from within them and adding both resultant trees to the next generation. This method is very powerful as the depths of the resultant children can range from 0 to the sum of the depths of the parents. The remaining part of the population is produced by selecting one parent in the same fitness-proportional manner and cloning it without mutation into the next generation. TODO: edit once finalized/include figures from Koza
\subsection{Identified Limitations}
Because of the nature of S-expressions, a given node cannot have multiple parents. This theoretically does not limit the capabilities of the sound synthesis algorithms produced by GP because an S-expression can have multiple identical terminals that would be identical in behavior to a node with multiple parents. However, this greatly increases search complexity and computation time for small and efficient algorithms such as FM synthesis using a single modulator and multiple carriers (the topology that \citep{horner1993machine} optimized parameters for using a genetic algorithm). Another limitation is lack of support for cyclic algorithms although as was hypothesized earlier this might not be of too much concern in the domain of target matching.
\subsection{Experiments}
\subsection{Results}
\subsection{Parameters}

\section{Interactive Evolution of Sound Synthesis Algorithms}
\begin{quote}
\emph{To seek out new tonalities, new timbres... \\
To boldly listen to what no one has heard before.} \citep{sethares2004tuning}
\end{quote}
\begin{quote}
The musical value of the computer does not lie, of course, in its ability to duplicate exactly what a real instrument can do, but rather in yielding an extended repertory of sounds, including and going beyond the classes of sounds of actual instruments. \citep{risset1969analysis}.
\end{quote}
\subsection{Method}
This experiment will use genetic programming to evolve synthesis algorithms directly, utilizing any set of primitives that the user chooses. The inputs to this system will be the user-selected primitives and the output will be multiple SSA's for the user to modify and evaluate. The user will be able to step through the evolutionary process, assigning fitness and auditioning the produced SSA's using a MIDI keyboard or virtual MIDI keyboard. The user may manipulate any variable constants of the produced SSA. The user may opt to input an audio file and let the synthesizer attempt to evolve towards it. The user may also let evolution experiment randomly using novelty search with unencountered fundamental/partial frequency ratios as the novelty goal.
\subsection{Parameters}
\subsection{Identified Limitations}
\subsection{Results}

\section{Implementation}
An early prototype for the interactive system was built using Cabbage, Csound and Python. After several performance limitations with this setup were encountered the implementation was switched to C++ and utilized the JUCE audio/GUI library. JUCE is a popular open-source library for developing audio plug-ins and was used as the core audio engine of this implementation as well as the graphics toolkit for the interactive GA. This project could not have been possible without JUCE and author/maintainer Jules's unrelenting demand for quality. Filter primitives were developed using the DSPFilters Library written and maintained by Vinnie Falco. Spectrum analysis for the fitness function was made possible by Kiss FFT, a relatively fast and extremely lightweight implementation of the Fast Fourier transform.
	
Target-matching tests were run on the UT Condor Computing Cluster with SPECS and each test took between MIN HOURS and MAX HOURS to complete. Interactive evolution tests were run on my own personal machine with SPECS by myself and a variety of users. TODO: fill in with actual data

\section{Conclusion}

\section{Future Work}

\section{Acknowledgements}
The author would like to thank the Computational Intelligence in Game Design lab, part of the University of Texas's Freshman Research Initiative program, for providing the tools and workspace to implement this project. Thanks to Joel Lehman for advice on the genetic algorithm aspects of this project. Thanks to Ashvin Bashyam for his help on my implementation of the Fourier transform-based fitness function. Thanks to TESTERS for kindly agreeing to test the interactive genetic algorithm. Finally, the author wishes to express gratitude to his advisors who were incredibly helpful throughout the process. TODO: fill in testers

%\section{For More Information and Download}
%cs.utexas.edu/~cdonahue/GPSynth.html (audio samples)
%github.com/cdonahue/gpsynth (source and downloadable/plugin versions of the interactive GA)

%\paragraph{Outline}
%The remainder of this article is organized as follows.
%Section~\ref{previous work} gives account of previous work.
%Our new and exciting results are described in Section~\ref{results}.
%Finally, Section~\ref{conclusions} gives the conclusions.

%\section{Results}\label{results}
%In this section we describe the results.

\bibliographystyle{abbrv}
\bibliography{bibthesis}

\end{document}

Main.cpp:
    Add command line for Envelope stuff somehow

GPExperiment.cpp:
    Pass time-varying variables to evaluate()
    do TODOs

GPSynth.cpp:
    Fill in more selectFromEvaluated() skeleton code including greedy over
    Maybe implement other types of reproduction
    do TODOs
    maybe remove rawFitness container

Node subclasses:
    DelayNode
    SplineNode other spline types
    NoiseNode other types of noise
    Envelope and Terminal could be subclasses of same code
    figure out and include true FM synthesis primitive
    more efficiency in subclasses. constantnode could be prerendered and memcpy'd during setRenderInfo, LFO node during updateMutatedParams with malloc in setRenderInfo, etc.


Ideas:
    use GPHelper to map a range for OscilNode's index of modulation
    crossover at shallower nodes have different probabilities? (exponentially distribute crossover point selection depth)
    finish implementing DifferenceEquationNode. turns out my difference equation idea from the start might have been better somehow. need to find a way to guarantee min/max though

Thoughts:
    Don't necessarily have to foray into filters too much. For now focus on best possible FM synthesis recreation
    Maybe can do filterednoise primative at a later point
    Multiple variable nodes to population... replace v0 oscil node with frequency determined by child
    consider constantNode intervalMutliply
        everything except constant has the tightest possible bound on min/max? hard to say
    synth partial continuous between [0, nyquist/centerfreq]?
        variablenode interval for cps stuff is 1 to nyquist
    consider separating min/max into ampmin/ampmax and calcmin/calcmax in order to facilitate ranging constants vs the amplitude they actually apply

TODO long run:
    Parser:
        createNode surrounds createNode parse into try except block. first error throws. prevents a whole lot of stuff from propogating
        add namespace

    try adding frequency child to OscilNode, adding variable0 primative into set and seeing if better matches are made... perhaps OscilNode still uses 0 + child value for detuning
	look at/fix all errors/warnings reported by visual studio (use rebuild command)

    supply input envelopes as files generated by small executables (IntroJucer command line apps)
        these will each be a variable that can be variable nodes/oscil terminals
        variables change over time
        organized by whole variable, not each at each time step for cache efficiency
        variable node for constants, variable node for changing variables
        (input_var {d 0 1 5}) for input variable 1 of 6
        (input_const {d 0 1 5}) for input constant 1 of 6
        (sinosc_var) (sinosc_const) etc etc
        numConstants, numVariables

    fitness function:
        fitness function considers noise somehow? as a separate factor alongside spectral/envelope and/or subtract noise from spectral evaluation
        fitness function compares candidate/target envelopes
        amp dB FFT for under/over comparison, not for fitness comparison due to -inf values for some bins... not sure how to deal with this

    long long run:
        Get filters (simple) working again. Switch filter libs probably
        implement a structure for fading more params by the convergence of the population. numeric mutation, numeric mutation amounts, mutation, etc.
        fleschter munsion? :/

TODO NEXT EXPERIMENTS:
    CMAES:
        read about how to limit number of generations
        start init values at current value to suboptimize future generations
    
    figure out why simple average fitness function seems to work the best
        maybe use naive average and blend with moving average?
        probably because it does a better job highlighting the peak. try moving average with very large radius to pick up the upper peaks as well. try constant penalty system
        consider changing proportion * bad + base to just bad + base...
        lower the average is on the frequency domain the better. probably want to do exponential moving average with like n/2 lookahead/behind in order to allow it to decrease towards the end to capture tiny partials

"a lot of decisions for the fitness function were made with human judgement from the output of their changes as any change to the fitness function leaves comparisons between fitness functions useless. so i graded by improvements in the underlying fitness function"

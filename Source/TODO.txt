Main.cpp:
    Add command line for Envelope stuff somehow
    check argument ranges
      renderBlockSize > frames in file?
      fftSize > frames in file?

GPExperiment.cpp:
    Pass time-varying variables to evaluate()
    do TODOs

GPSynth.cpp:
    Fill in more selectFromEvaluated() skeleton code including greedy over
    Maybe implement other types of reproduction
    do TODOs
    maybe remove rawFitness container
	change allNetworks in GPSynth to std::string not std::string*.... so stupid

Node subclasses:
    DelayNode
    SplineNode other spline types
    NoiseNode other types of noise
    toString for all subclasses could be moved to GPNode with std::string symbol
    Envelope and Terminal could be subclasses of same code
    figure out and include true FM synthesis primitive
    more efficiency in subclasses. constantnode could be prerendered and memcpy'd during setRenderInfo, LFO node during updateMutatedParams with malloc in setRenderInfo, etc.

Interactive:
    10 networks, 4 or 5 faders, one keyboard
    Button to interactively suboptimize constants
    Ability to edit network
    PITCHBEND
    Introduce Novelty button replaces current network with new full()
    Buttons to step backwards through evolution
    button to run random evolution for a while towards a target with best suboptimization method
    novelty search of new spectrum elements/spectral peak ratios
    Add max note length as a slider to GUI in order to make TimeNode potentially useful
    primative/options menu:
        available primitives (two adjacent lists) (oscils with center frequency at 3rd, 4th, 5th, 7th, etc)
        maxNoteLength
        maxNetworkHeight
	
	v0.2:
		more primitives
            may have to implement wave table reading synthesis with interpolation
            generator nodes would then just generate buffer based on mutatable params at setRenderInfo time or construction depending on what is necessary
            could try Audacity stuff for now
            FINISH and TEST SPLINE
        options page:
            num networks
            maxnotelen
            maxnetworkheight
            initialnetworkmaxheight
            primitive selector
        random button
        reset button
        string view of network with sliders for mutatable params and update button
		check how fitness probabilities are working
		display name of synth if loaded or saved
        vst plugin save current generation

Names:
	synthsearch
	exploration synthesis
		
Web:
	Save button posts network to mySQL db
	make personal website utilizing django in some way for practice
	maybe make database entries for synthesizers in order to set up a platform for future use
	figure out how to host stuff on UTCS
	host the web server from NN lab. also go there to get form

Ideas:
    use GPHelper to map a range for OscilNode's index of modulation
    crossover at shallower nodes have different probabilities? (exponentially distribute crossover point selection depth)
    finish implementing DifferenceEquationNode. turns out my difference equation idea from the start might have been better somehow. need to find a way to guarantee min/max though
    mutation using original network as a subtree of a new full() call? check Koza for precedence

Thoughts:
    Don't necessarily have to foray into filters too much. For now focus on best possible FM synthesis recreation
    Maybe can do filterednoise primative at a later point
    Multiple variable nodes to population... replace v0 oscil node with frequency determined by child
    consider constantNode intervalMutliply
        everything except constant has the tightest possible bound on min/max? hard to say
    synth partial continuous between [0, nyquist/centerfreq]?
        variablenode interval for cps stuff is 1 to nyquist
    consider separating min/max into ampmin/ampmax and calcmin/calcmax in order to facilitate ranging constants vs the amplitude they actually apply

TODO long run:
	split GPParams into GPMatchingExperimentParams, GPSynthParams and perhaps GPNodeParams

    Parser:
        createNode surrounds createNode parse into try except block. first error throws. prevents a whole lot of stuff from propogating
        add namespace to JUCEFileIO and GPParser

    try adding frequency child to OscilNode, adding variable0 primative into set and seeing if better matches are made... perhaps OscilNode still uses 0 + child value for detuning
	look at/fix all errors/warnings reported by visual studio (use rebuild command)
    figure out how to start without being in initialise method (new thread)
    print ranges/save all networks in text file that can be used from command line to render all generation wavs/just save ID's instead of waves
    
    improve numerical mutation:
        maybe relate numericalMutation to the fitness of the individual. this way particular numbers can be altered more in accordance to deviations from the mean
        check if temperature mapping is working as i would like it to

    fitness function:
        fitness function considers noise somehow? as a separate factor alongside spectral/envelope and/or subtract noise from spectral evaluation
        fitness function compares candidate/target envelopes
        amp dB FFT for under/over comparison, not for fitness comparison due to -inf values for some bins... not sure how to deal with this

    long long run:
        Get filters (simple) working again. Switch filter libs probably
        implement a structure for fading more params by the convergence of the population. numeric mutation, numeric mutation amounts, mutation, etc.
        fleschter munsion? :/

TODO NEXT EXPERIMENTS:
    CMAES:
        read Garcia paper to see how he did his suboptimizing GA. try testing that too
        figure out how to retrieve champion and use that for population
        read abuot how to limit number of generations

    figure out why simple average fitness function seems to work the best
        maybe use naive average and blend with moving average?
        probably because it does a better job highlighting the peak. try moving average with very large radius to pick up the upper peaks as well. try constant penalty system
        consider changing proportion * bad + base to just bad + base...
        lower the average is on the frequency domain the better. probably want to do exponential moving average with like n/2 lookahead/behind in order to allow it to decrease towards the end to capture tiny partials

"a lot of decisions for the fitness function were made with human judgement from the output of their changes as any change to the fitness function leaves comparisons between fitness functions useless. so i graded by improvements in the underlying fitness function"

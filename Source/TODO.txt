Main.cpp:
    Add command line for Envelope stuff somehow
    --help
    check argument ranges
      renderBlockSize > frames in file?
      fftSize > frames in file?

GPExperiment.cpp:
    Pass time-varying variables to evaluate()
    fill and use sampleTimes for efficiency
    do TODOs

GPNetwork.cpp:
    Add new syntax parsing to string parser once node subclasses finalized
    
GPSynth.cpp:
    Fill in selectFromEvaluated() skeleton code including greedy over
    Maybe implement other types of reproduction
    do TODOs
    maybe remove rawFitness container

Node subclasses:
    DelayNode
    ConditionalNode
    NoiseNode other types of noise
    consider changing evaluate to return floats as well as all GPFUNCTIONS... (float) double efficiency?

Interactive:
    10 networks, 4 or 5 faders, one keyboard
    Button to interactively suboptimize constants
    Ability to edit network test and add things like PITCHBEND
    Introduce Novelty button
    Buttons to step backwards through evolution
    button to run random evolution for a while
    novelty search of new spectrum elements/spectral peak ratios
    Add max noet length as a slider to GUI in order to make TimeNode potentially useful
    link visual studio with boost
    interval variable as primatives? (open 5th, 4th, etc).
    are min/max always constant? do we need to have this be a param for evaluateBlockPerformance? Maybe it could be done during traceNetwork
    variablenode interval for cps stuff is 1-nyquist

Ideas:
    use GPHelper to map a range for OscilNode's index of modulation
    crossover at shallower nodes have different probabilities? (exponentially distribute crossover point selection depth)
    finish implementing DifferenceEquationNode. turns out my difference equation idea from the start might have been better somehow. need to find a way to guarantee min/max though
    maybe add "prepare to play" abstract to GP node to replace if (fn == 0)
    framework to change constants over time that depend on pop convergence

Thoughts:
    Don't necessarily have to foray into filters too much. For now focus on best possible FM synthesis recreation
    Maybe can do filterednoise primative at a later point
    Add spline to likely replace ADSR
    LFO nodes too
    Multiple variable nodes to population... replace v0 oscil node with frequency determined by child
    should variablenum in VariableNode be a mutatable param?
    for fitness function, lower the average is on the frequency domain the better. probably want to do exponential moving average with like n/2 lookahead/behind in order to allow it to decrease towards the end to capture tiny partials

TODO long run:
    calculate min/max stuff with lo/hi filter node if you have resonance, alter bandwidth/quality calculation
    print ranges/save networks in text file/just save ID's in waves
    update README
    implement a structure for fading more params by the convergence of the population. numeric mutation, numeric mutation amounts, mutation, etc.
    figure out how to start without being in initialise method (new thread)
    fleschter munsion? :/
    Check if numerical mutation is working...
        maybe relate numericalMutation to the fitness of the individual. this way particular numbers can be altered more in accordance to deviations from the mean
    fitness function considers noise somehow? as a separate factor alongside spectral/envelope and/or subtract noise from spectral evaluation
    fitness function compares candidate/target envelopes
    amp dB FFT for under/over comparison, not for fitness comparison due to -inf values for some bins... not sure how to deal with this
    commandline flag --condorbackup which saves certain files only if seed == 0 or something
    try adding frequency child to OscilNode, adding variable0 primative into set and seeing if better matches are made... perhaps OscilNode still uses 0 + child value for detuning
    exponential ADSR?
    Get filters (simple) working again. Switch filter libs probably
    consider changing proportion * bad + base to just bad + base...

NEXT EXPERIMENTS:
    FUNCTION NODE OVERHAUL:
        AddNode, MultiplyNode, etc. are subclasses of FunctionNode.
        all haev own implementation of evaluateBlockPerformance but they all inherit evaluteBlock
    NODES restructure:
        remove samplerate from constructor, moved to setRenderInfo
        do all malloc stuff in setRenderInfo so we're not calling malloc in evaluateBlockPerformance
        ignore evaluateBlock for now, just use performance
        finish function node stuff
        learn more about inheritance, should be able to call super() from setRenderInfo for most stuff
        change updateMutatedParams to updatedSubtree and make it virtual with default implementation
        change setRenderInfo to be part of updateMutatedParams(samplerate, blocksize, maxtime)
        prepareToRender calls setRenderInfo and traceNetwork restores lineage/heights/allnodes/allmp
        remove timeNodeMaxSeconds turn it into something in GPExperiment
    create test suite to confirm that all primitives are working correctly
        copy construct
        make sure all silent before updateMutatedParams which will become updateSubtree maybe
        figure out printing (pi) stuff
        figure out why sin wave sounds aliased (probably pi as double deal)
    move champ tracking to GPSynth not GPEXperiment
    probably remove getRange() and just have it return minimum/maximum set by constructors
        change updateMutatedParams() to updateSubtree() which will:
            update mutated params
            update new min/max values from children
        updateSubtree() will be called either in GPNetwork traceNetwork or in addNetworkToPopulation

        when am i CALLING updateMutatedParams()?!
            do I need to be calling it in addNetworkToPopulation? for mutation?
        move all minimum maximum calculations to float and in updateParams()/fillFromParams()

    test random
    test numerical mutation/consider CMAES
    figure out why simple average fitness function seems to work the best
    go through 4.24.13.b results iteratively and see what worked and what didnt. test a lot of instruments of a lot of different types on this to see what it can come up with.
    THESIS WORK

"a lot of decisions for the fitness function were made with human judgement from the output of their changes as any change to the fitness function leaves comparisons between fitness functions useless. so i graded by improvements in the underlying fitness function"

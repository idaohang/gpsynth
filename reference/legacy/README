Evolutionary Synthesizer User ManualChris Donahue (christopherdonahue@gmail.com)Dec 14 2012v0.1===================================           Introduction===================================The evolutionary synthesizer takes inspiration from genetic programming to create synthesis algorithms using expression trees. Genetic programming or GP is a supervised learning technique that attempts to discover functions by simulating natural evolution. In GP, a fitness function determines the likelihood that an expression tree will reproduce (through mutation or cross breeding) into the next generation. In the case of the evolutionary synthesizer, the fitness of each network is determined by whether or not the user clicks its corresponding check box.The synthesizer starts with a uniform population of 5 synth patches, all producing pure sine waves. The equation for this is: sin(2*pi*f*t) where f is the desired frequency and t is the time since the start of the note. Represented as an expression tree string, this is (sin (* (* (* 2 pi) f) t)). This is an atypical way to start a genetic programming experiment, but necessary for the particular search space of "musical" equations. This is the first in a number of diversions from pure genetic programming in order to adapt the technique more suitably to the domain of synthesis.===================================              Set-up===================================In order to use the evolutionary synthesizer, you must ensure that you have Csound and Python on your system path. You must also have Cabbage installed. Additionally, "gpimport.py" and "sine.png" must be in the same folder as Cabbage. Start cabbage and open the patch. You should be able to use a MIDI controller to produce sound, and initially you will only hear sine waves. If the synth sounds choppy when playing a single note, open "evosynth.csd" and increase "ksmps" on line 60. It is set to 5 by default, meaning a sample is produced every 5 audio samples and there is linear interpolation between them. If you have a more powerful processor, try decreasing the "ksmps" variable as low as it will go until the sound gets choppy. The more polyphony you use, the more computation power required.===================================Explanation of Synthesizer Sections==================================="test population":	This section allows you to audition the synthesizers in the current population	synth #: This slider allows you to audition any of the 5 synths in the current population	gain: This slider controls how loud the output is. May be necessary to adjust to avoid clipping when expression trees become arbitrarily complex.	networks: This button allows you to view the expression trees of the current and past generations as text. May not work on operating systems besides Windows."selection":	This is where you can select which synthesizers of the current population you prefer. If nothing is selected, all of the current synthesizers have an equal chance of being selected for reproduction and mutation. IF ONE OR MORE ARE SELECTED, THOSE SYNTHESIZERS WILL BE THE ONLY ONES THE ALGORITHM CAN POSSIBLY SELECT FROM TO POPULATE THE NEXT GENERATION. If you only select one, the next population will sound quite uniform except in the case of drastic mutation.	"generation control":	This allows you to step forward and backward through the experiment. When you are done selecting the synthesizers you like, adjust the parameters to your liking and click "next" to advance the generation. Clicking "previous" will revert the patch back to the last set of synthesizers. At this point in time, the "evolution parameters" sliders are essentially ignored the first time one presses "next" due to a discovered limitation in the mutation logic. Initial mutations simply add modulation subtrees to all networks selected for mutation. After the first generation however, the sliders are fully active and this limitation will be corrected soon.	"function likelihood weights":	This is where you can adjust the internal likelihoods of selecting a particular function for mutations that involve such a selection. If all are set to the same level (regardless of what that level is), selection is uniformly random."evolution parameters":	This is the most complicated section of the patch, but is still quite managable once you wrap your head around it. I will detail each of them individually.		mutate: (initially 1.0)		This slider controls the possibility of mutation happening for each synthesizer produced for the next generation.	simp/comp: (initially 0.0)		This slider controls the likelihood of mutations that simplify the expression tree vs. mutations that complexify the expression tree. If the slider is set to 0, there it is certain that mutations will complexify the expression trees. If the slider is set to 1, it is certain that mutations will simplify the expression trees and the "spcl/norml", "harmn/mdltn", "fnc/val" sliders will be ignored.	spcl/norml: (initially 0.5)		This slider controls the likelihood of "special" vs "normal" mutations. "Special" mutations involve adding harmonics or modulation subtrees to the tree. "Normal" mutations involve swapping functions and changing constant values. If the slider is set to 0, only normal mutations will happen and the "hrmn/mdltn" slider is ignored. If the slider is set to 1, only special mutations will happen and the "fnc/val" slider is ignored.	harmn/mdltn: (initially 0.5):		This slider controls the likelihood of a harmonic or modulation subtree being added to an expression tree should a special mutation happen. If set to 0, only modulation subtrees will be added (giving the population a greater chance of sounds that change over time). If set to 1, only harmonic subtrees will be added (increasing the spectral richness of the population)	fnc/val: (initially 0.5):		This slider controls the likelihood of a function or value being mutated should a normal mutation happen. If set to 0, constant values will be added/perturbed. If set to 1, existing functions in the expression tree will be randomly selected and swapped.	cross: (initially 0.2):		This slider controls the likelihood of two networks in the population crossing with each other through ring modulation. These crosses are computationally expensive and can get out of hand quickly, so it is recommend to keep this at 0 most of the time unless you find two sounds and want to hear a hybrid sound that is a combination of both (by setting cross to 1.0 and mutate to 0.0).		===================================            Limitations===================================	The evolutionary synthesizer in its current state is admittedly limited. The most obvious current limitation is that one cannot save patches and recall them in future generations or on other iterations of the experiment. (If you find a patch you really like, save the text of it from 'networks.txt' as I will soon add the ability to recall patches from text.) There are performance issues on the Python side of things. It is likely that the interface between Python and Csound has some significant overhead that may or may not be fixable. Other limitations seem to be on the Cabbage side; the program crashes semi-frequently when adjusting or playing too much at once. Also, running the synthesizer as a VST plugin works but one must remove the Python code for writing out to files. Finally, the mutation code could use some purification. Some of the decisions made were relatively arbitrary and with more time I should be able to make the synthesizer move more intuitively towards the goal the user has in mind.